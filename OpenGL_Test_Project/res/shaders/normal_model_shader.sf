#version 330

uniform sampler2D materialTexture;
uniform sampler2D normalMap;

struct LightIntensity {
	vec3 Ld;
	vec3 Ls;
	vec3 La;
};

struct MaterialInfo {
	vec3 Kd;
	vec3 Ks;
	vec3 Ka;
};

struct SpotLightInfo {
	vec3 intensity;
	vec3 direction;
	float exponent;
	float cutoff;
};

varying vec2 texCoords;
varying vec3 normal;
varying vec3 toLightVector;
varying vec3 toSpotLighVector;
varying vec3 toCameraVector;
varying vec3 position;
varying float visibility;
varying vec3 normalTex;
varying vec3 tangent;

uniform LightIntensity lightInfo;
uniform SpotLightInfo spotLight;
uniform MaterialInfo materialInfo;
uniform vec3 fogColor;

vec3 adsSpotLight() {
	float dotSpotLight = max(dot(spotLight.direction, toSpotLighVector),0);
	float angle = acos(dotSpotLight);

	if(angle <= spotLight.cutoff) {
		float spotFactor = pow(dotSpotLight, spotLight.exponent);
		vec3 h = normalize(toCameraVector - toSpotLighVector);

		return spotFactor * spotLight.intensity * (
			materialInfo.Kd * max(dot(-toSpotLighVector, normal), 0) +
			materialInfo.Ks * pow(max(dot(h, normal),0), 8)
		);
	}

	return vec3(0);
}

vec4 basicLight() {
	return vec4(0);
}

vec4 phongLight(vec3 toLightVector, vec3 toCameraVector, vec3 normal) {
	float diffuseFactor = dot(toLightVector, normal);

	vec3 diffuseColor = vec3(0);
	vec3 specularColor = vec3(0);

	if(diffuseFactor > 0) {
		diffuseColor = lightInfo.Ld * materialInfo.Kd * diffuseFactor;

		vec3 reflectedLight = normalize(reflect(-toLightVector, normal));
		//vec3 halfVector = normalize(toCameraVector + normal);
		float specularFactor = dot(reflectedLight, toCameraVector);
		//float specularFactor = dot(halfVector, toCameraVector);

		if(specularFactor > 0) {
			specularFactor = pow(specularFactor, 10);
			specularColor = lightInfo.Ls * materialInfo.Ks * specularFactor;
		}
	}

	return vec4(diffuseColor + specularColor + 0.2, 1.0);
}

void main() {
	vec4 outColor = texture2D(materialTexture, texCoords);
	vec3 normalMapNormals = 2 * texture2D(normalMap, texCoords).xyz - 1;

	if(outColor.a < 0.5) {
		discard;
	}

	vec3 attenuation = vec3(0.01, 0.01, 0.01);
	float distance = length(toLightVector);
	float attFactor = attenuation.x + attenuation.y*distance + attenuation.z*distance*distance;

	vec3 toLightVector1 = normalize(toLightVector);
	vec4 light = phongLight(toLightVector1, toCameraVector, normalMapNormals);
	//light = light/attFactor;

	vec4 spotLightColor = vec4(0);
	if(toSpotLighVector.x != 101) {
		spotLightColor = vec4(adsSpotLight(), 1.0);
	}

	gl_FragColor = mix(vec4(fogColor,1), outColor * (light + (0)), visibility);
}